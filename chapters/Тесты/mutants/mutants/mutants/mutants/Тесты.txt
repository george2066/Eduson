Unit-тесты помогают проверять отдельный объект кода — модуль, класс и т. д.
Интеграционные тесты проверяют логику компонентов в связке с базой данных и/или сервером. В чем назначение каждого теста 
Системные тесты позволяют проверить компоненты, которые зависят от операционной системы и «железа».
Приемочные тесты проверяют метрики, которые определяют готовность проекта.
E2E-тесты проверяют работоспособность готового приложения на верхнем уровне. Например, работу кнопок, форм и т. д.

Ну обычный юнит тест проверяется assert result == True в методе, вместо return
Есть ещу библиотека pytest, которой пользуются для тестов в 99.99% случаев, только перед методом тество нужно написать # tests/
Если нужно проверить сразу несколько значений, то тогда пишут вот что:
@pytest.mark.parametrize(
	'price', [2, 4, 6, 8, 10]
)

Только нужно, чтобы price принимался как аргумент теста

Если нужно проверить ошибку:
@pytest.mark.parametrize(
	'x', [-2, -4, -6, -8, -10]
)
def coren(x):
	with pytest.raise(ValueError) as exinfo:
		Coren(x)
	assert str(exinfo) == 'Х должен быть положительным'

Чтобы посмотреть какие методы покрыты тестами, да и вообще процент покрытия тестами кода взгляните на run.sh, в котором используется плагинчик coverage, который при запуске тестов в терминал добавляет информацию.
Второй командой там идёт как раз запись в штмл файл, чтобы потом в браузере посмотреть какой код покрыт тестами.
А если мы намерено не хотим, чтобы какой-то метод в каком-то классе, который не реализовывает никакой логики, читался coverage, то мы около его последней строки (последней строки метода) приписываем # pragma: no cover
Ну и запускаем coverage
./run.sh

Важный момент: если у вас питон ругается на start, то поставьте open.
Если питон ругается на py.test: ошибка: нераспознанные аргументы: --cov-report --cov=, то поставьте pip install pytest-cov

Теперь научимся их группировать
Да просто распихать их всех по логике в классы, да и всё! Типа тесты с положительными сценариями, тесты с отрицательными сценариями.

Теперь узнаем что такое проперти бест
Типа подстановка каких-то рандомных значений. Можно их подставлять начиная от простых строк до каких-то сложных классов.
То есть был такой метод:
def test_book_creation():
    price = 400
    book = Book(price)
    assert book.price == price

Стал вот такой:
def test_book_creation(faker: Faker):
    faker.seed_instance(1234) делаем значение статичным
    price = faker.pyint(min_value=0)
    book = Book(price)
    assert book.price == price

Ну фейкер для обработки ошибки вы сами посмотрите в файле

С моками посмотрите и разберитесь сами в коде (MailClient)

Мутационные тесты!

Это те же самые тесты, но чуть повидоизменённее.
В файле mut.sh прописан код
Перед запуском установите mutmut и resource
Если у вас сраная винда, такая же сраная как и пингвин, то скачайте wsl --install


